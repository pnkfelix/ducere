
use crate::expr::{Expr, Var, BinOp};
use crate::{Grammar, Rule, RegularRightSide, NonTerm, normalize_escapes, YakkerError};
use lalrpop_util::ParseError;

grammar;

match {
    r#""(\\"|[^"])*""# => STRING_LIT
} else {
    _
}

extern {
    type Error = YakkerError;
}

pub Grammar: Grammar = {
    <r:Rule> ";"? =>
        Grammar { rules: Some(r).into_iter().collect() },
    <r:Rule> ";" <g: Grammar> =>
        Grammar { rules: Some(r).into_iter().chain(g.rules.into_iter()).collect() }
};

pub Rule: Rule = <nt:ParametricNonTerm> "::=" <r:RegularRightSide> => Rule(nt.0.into(), nt.1, r);

pub ParametricNonTerm: (NonTerm, Option<Var>) = {
    <nt:NonTerm> "(" <v:Var> ")" => (nt, Some(v)),
    <nt:NonTerm> => (nt, None),
};

pub RightSideLeaf: RegularRightSide = {
    "(" <RegularRightSide> ")" => <>,
    r#"''"# => RegularRightSide::EmptyString,
    "empty" => RegularRightSide::EmptyLanguage,
    <t:r"'[^'\\]'"> => RegularRightSide::Term(t[1..t.len()-1].into()),

    <a:NonTerm> =>
            RegularRightSide::NonTerm { x: None, A: a, e: None },
    "<" <a:NonTerm> ">" =>
            RegularRightSide::NonTerm { x: None, A: a, e: None },
    "<" <a:NonTerm> "(" <e:Expr> ")" ">" =>
            RegularRightSide::NonTerm { x: None, A: a, e: Some(e) },
    "<" <x:Var> ":=" <a:NonTerm> "(" <e:Expr> ")" ">" =>
            RegularRightSide::NonTerm { x: Some(x), A: a, e: Some(e) },
    <x:Var> ":=" <a:NonTerm> =>
            RegularRightSide::NonTerm { x: Some(x), A: a, e: None },
    "<" <x:Var> ":=" <a:NonTerm> ">" =>
            RegularRightSide::NonTerm { x: Some(x), A: a, e: None },
    "{" <x:Var> ":=" <e:Expr> "}" =>
            RegularRightSide::Binding { x, e },
    "[" <e:Expr> "]" =>
        RegularRightSide::Constraint(e),
//    <b:BlackBox> "(" <e:Expr> ")" =>
//        RegularRightSide::Blackbox(e)),
};

// Of the three recursive cases for regular right sides,
// concatenation, alternation, and Kleene-closure,
// Kleene binds most tightly, and alternative most loosely, like so:
//
// r1 r2* | r3 r4*
// is equivalent to:
// ((r1 (r2*)) | (r3 (r4*)))
//
// As noted in its book, LALRPOP does not have any special features for
// encoding precedence; you just have to structure your grammar in tiers.

pub RegularRightSide: RegularRightSide = Alternates;

pub Alternates: RegularRightSide = {
    <a:Alternative> => a,
    <a:Alternative> "|" <alts:Alternates> => RegularRightSide::Either(Box::new(a), Box::new(alts)),
}

pub Alternative: RegularRightSide = {
    <r:Concatenant> => r,
    <r:Concatenant> <rs:Alternative> => RegularRightSide::Concat(Box::new(r), Box::new(rs)),
};

pub Concatenant: RegularRightSide = {
    <RightSideLeaf> => <>,
    <RightSideLeaf> "*" => RegularRightSide::Kleene(Box::new(<>)),
};

pub Var: Var = <s:r"[a-z_][a-zA-Z_0-9]*"> => Var(s.to_string());
pub NonTerm: NonTerm = <s:r"[A-Z][a-zA-Z_0-9]*"> => NonTerm(format!("{}", s.chars().next().unwrap()));

pub Expr: Expr = CmpExpr;

pub CmpExpr: Expr = {
    <e:AddSeq> => e,
    <e1:AddSeq> "==" <e2:AddSeq> => Expr::BinOp(BinOp::Eql, Box::new(e1), Box::new(e2)),
    <e1:AddSeq> "eql" <e2:AddSeq> => Expr::BinOp(BinOp::Eql, Box::new(e1), Box::new(e2)),
    <e1:AddSeq> "!=" <e2:AddSeq> => Expr::BinOp(BinOp::Neq, Box::new(e1), Box::new(e2)),
    <e1:AddSeq> "neq" <e2:AddSeq> => Expr::BinOp(BinOp::Neq, Box::new(e1), Box::new(e2)),
    <e1:AddSeq> ">" <e2:AddSeq> => Expr::BinOp(BinOp::Gt, Box::new(e1), Box::new(e2)),
    <e1:AddSeq> "gt" <e2:AddSeq> => Expr::BinOp(BinOp::Gt, Box::new(e1), Box::new(e2)),
    <e1:AddSeq> ">=" <e2:AddSeq> => Expr::BinOp(BinOp::Ge, Box::new(e1), Box::new(e2)),
    <e1:AddSeq> "ge" <e2:AddSeq> => Expr::BinOp(BinOp::Ge, Box::new(e1), Box::new(e2)),
    <e1:AddSeq> "<" <e2:AddSeq> => Expr::BinOp(BinOp::Lt, Box::new(e1), Box::new(e2)),
    <e1:AddSeq> "lt" <e2:AddSeq> => Expr::BinOp(BinOp::Lt, Box::new(e1), Box::new(e2)),
    <e1:AddSeq> "<=" <e2:AddSeq> => Expr::BinOp(BinOp::Le, Box::new(e1), Box::new(e2)),
    <e1:AddSeq> "le" <e2:AddSeq> => Expr::BinOp(BinOp::Le, Box::new(e1), Box::new(e2)),
}

pub AddSeq: Expr = {
    <e:AddArg> => e,
    <e1:AddSeq> "+" <e2:AddArg> => Expr::BinOp(BinOp::Add, Box::new(e1), Box::new(e2)),
    <e1:AddSeq> "-" <e2:AddArg> => Expr::BinOp(BinOp::Sub, Box::new(e1), Box::new(e2)),
};

pub AddArg: Expr = MulSeq;

pub MulSeq: Expr = {
    <e:MulArg> => e,
    <e1:MulSeq> "*" <e2:MulArg> => Expr::BinOp(BinOp::Mul, Box::new(e1), Box::new(e2)),
    <e1:MulSeq> "/" <e2:MulArg> => Expr::BinOp(BinOp::Div, Box::new(e1), Box::new(e2)),
};

pub MulArg: Expr = {
    <v:Var> => Expr::Var(v),
    "true"  => true.into(),
    "false" => false.into(),
    <n:r"[1-9][0-9]*|0"> => Expr::Lit(n.parse::<i64>().unwrap().into()),
    "()"    => ().into(),
    "(" <e:Expr> ")"    => e,
    <s:STRING_LIT> =>?
        normalize_escapes(&s[1..s.len()-1])
            .map(|s|s.into())
            .map_err(|e| ParseError::User { error: e }),
}