
use crate::expr::{Expr, Var};
use crate::{Rule, RegularRightSide, NonTerm, normalize_escapes, YakkerError};
use lalrpop_util::ParseError;

grammar;

extern {
    type Error = YakkerError;
}

match {
  r"[a-c]" => TERM,
  r"[x-z]" => VAR,
  r"[A-Z]" => NON_TERM,
} else {
  _
}

pub Rule: Rule = <nt:NonTerm> "::=" <r:RegularRightSide> => Rule(nt.into(), r);

pub RegularRightSide: RegularRightSide = {
    "" => RegularRightSide::EmptyString,
    "empty" => RegularRightSide::EmptyLanguage,
    <t:TERM> => RegularRightSide::Term(t.into()),
    <x:Var> ":=" <a:NonTerm> "(" <e:Expr> ")" =>
            RegularRightSide::NonTerm { x, A: a, e },
    <x:Var> ":=" <e:Expr> =>
            RegularRightSide::Binding { x, e },
};

pub Var: Var = <s:VAR> => Var(s.chars().next().unwrap());
pub NonTerm: NonTerm = <s:NON_TERM> => NonTerm(format!("{}", s.chars().next().unwrap()));

pub Expr: Expr = {
    <v:Var> => Expr::Var(v),
    "true"  => true.into(),
    "false" => false.into(),
    "()"    => ().into(),
    <s:r#""(\\"|[^"])*""#> =>?
        normalize_escapes(&s[1..s.len()-1])
            .map(|s|s.into())
            .map_err(|e| ParseError::User { error: e }),
};
